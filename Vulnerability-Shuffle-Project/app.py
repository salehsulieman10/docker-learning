# app.py

from flask import Flask, render_template
import random
import mysql.connector


app = Flask(__name__)

VULNERABILITIES = [
    {
        "name": "SQL Injection (SQLi)",
        "category": "Injection",
        "description": "Attacker injects malicious SQL into queries to read, modify, or delete data.",
        "impact": "Data theft, data loss, authentication bypass, full database compromise.",
        "mitigation": "Use parameterized queries/ORMs, input validation, least-privilege DB accounts, and stored procedures."
    },
    {
        "name": "Cross-Site Scripting (XSS)",
        "category": "Injection",
        "description": "Attacker injects malicious JavaScript into web pages viewed by other users.",
        "impact": "Session hijacking, credential theft, defacement, browser-based malware delivery.",
        "mitigation": "Output encode all untrusted data, use CSP, sanitize input, and avoid dangerous HTML injection."
    },
    {
        "name": "Cross-Site Request Forgery (CSRF)",
        "category": "Session / Authorization",
        "description": "Tricks a logged-in user’s browser into sending unintended requests to a web app.",
        "impact": "Unauthorized actions performed as the victim (fund transfers, password changes, etc.).",
        "mitigation": "Use CSRF tokens, SameSite cookies, and re-authentication for sensitive actions."
    },
    {
        "name": "Broken Authentication",
        "category": "Authentication",
        "description": "Weak or flawed authentication mechanisms allow attackers to impersonate users.",
        "impact": "Account takeover, privilege escalation, access to sensitive data.",
        "mitigation": "Use secure frameworks, MFA, lockouts, secure password storage, and strong session management."
    },
    {
        "name": "Sensitive Data Exposure",
        "category": "Data Protection",
        "description": "Sensitive data is not properly protected in transit or at rest.",
        "impact": "Leak of PII, credentials, financial data, regulatory violations.",
        "mitigation": "Enforce TLS, encrypt data at rest, avoid storing secrets in code, and use strong key management."
    },
    {
        "name": "Security Misconfiguration",
        "category": "Configuration",
        "description": "Insecure default settings, verbose error messages, or unnecessary features left enabled.",
        "impact": "Easier exploitation, information disclosure, and widened attack surface.",
        "mitigation": "Harden configs, disable unused services, patch regularly, and standardize builds."
    },
    {
        "name": "Insecure Direct Object Reference (IDOR)",
        "category": "Access Control",
        "description": "App exposes object identifiers directly without proper authorization checks.",
        "impact": "Unauthorized access to other users’ records or resources.",
        "mitigation": "Enforce authorization on every request and avoid trusting user-supplied IDs."
    },
    {
        "name": "Server-Side Request Forgery (SSRF)",
        "category": "Network / Access",
        "description": "Attacker makes the server send requests to internal or external systems.",
        "impact": "Access to internal services/metadata, pivoting inside cloud networks.",
        "mitigation": "Deny-list internal addresses, use allow-lists, and restrict outbound network access."
    },
    {
        "name": "Remote Code Execution (RCE)",
        "category": "Code Execution",
        "description": "Attacker can run arbitrary code on the server due to unsafe input handling.",
        "impact": "Full system compromise, lateral movement, data destruction.",
        "mitigation": "Avoid unsafe eval/system calls, validate inputs, and sandbox risky functionality."
    },
    {
        "name": "Command Injection",
        "category": "Injection",
        "description": "Untrusted input is passed to OS commands without proper sanitization.",
        "impact": "Execution of arbitrary OS commands using the app’s privileges.",
        "mitigation": "Avoid shell calls; if needed, use safe APIs, validate inputs, and escape arguments."
    },
    {
        "name": "Path Traversal",
        "category": "File Handling",
        "description": "Attacker manipulates file paths to access files outside the intended directory.",
        "impact": "Reading sensitive files, overwriting configuration or log files.",
        "mitigation": "Normalize and validate paths, use allow-listed directories, and avoid using raw user input in paths."
    },
    {
        "name": "XML External Entity (XXE)",
        "category": "Injection",
        "description": "Malicious XML with external entities is processed by a vulnerable parser.",
        "impact": "File disclosure, SSRF, denial of service.",
        "mitigation": "Disable external entity resolution and use safe XML parsers or alternative formats like JSON."
    },
    {
        "name": "Insecure Deserialization",
        "category": "Object Handling",
        "description": "Untrusted data is deserialized into objects without validation.",
        "impact": "RCE, injection, or logic abuse depending on the application.",
        "mitigation": "Avoid deserializing untrusted data, sign/validate serialized objects, and use safer formats."
    },
    {
        "name": "Clickjacking",
        "category": "UI Redress",
        "description": "Attacker overlays invisible frames to trick users into clicking hidden elements.",
        "impact": "Unintended actions like changing settings, approving transactions.",
        "mitigation": "Use X-Frame-Options or CSP frame-ancestors, and consider UI confirmation for critical actions."
    },
    {
        "name": "Weak Password Policies",
        "category": "Authentication",
        "description": "Passwords are easy to guess or reused across systems.",
        "impact": "Credential stuffing and brute-force compromise of accounts.",
        "mitigation": "Enforce strong password requirements, block common passwords, and encourage password managers."
    },
]


def get_visit_count():
    """
    Simple MySQL-backed visit counter.
    Uses the 'mydb' service from docker-compose as the DB host.
    """
    conn = mysql.connector.connect(
        host="mydb",           # service name from docker-compose.yml
        user="root",           # match your MySQL user
        password="my-secret-pw",  # match your MySQL password
        database="mysql"       # default DB; you can change this
    )
    cursor = conn.cursor()

    # Create a table to track visits if it doesn't exist
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS visits (
            id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
            ts TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    """)

    # Insert a row for this visit
    cursor.execute("INSERT INTO visits () VALUES ()")
    conn.commit()

    # Count total visits
    cursor.execute("SELECT COUNT(*) FROM visits")
    (count,) = cursor.fetchone()

    cursor.close()
    conn.close()
    return count


@app.route("/")
def index():
    vuln = random.choice(VULNERABILITIES)
    visit_count = get_visit_count()
    return render_template("index.html", vuln=vuln, visit_count=visit_count)


if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5002)
